-- Enable Row Level Security
alter default privileges in schema public grant all on tables to postgres, anon, authenticated, service_role;

-- PROFILES (Users)
create table profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  email text,
  avatar_url text,
  dob date,
  is_admin boolean default false,
  is_banned boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- handle new user signup
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, username, email, avatar_url, dob)
  values (
    new.id, 
    new.raw_user_meta_data->>'username', 
    new.email,
    new.raw_user_meta_data->>'avatar_url',
    (new.raw_user_meta_data->>'dob')::date
  );
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- SERIES
create table series (
  id bigint generated by default as identity primary key,
  name text unique not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table series enable row level security;

create policy "Series are viewable by everyone."
  on series for select using ( true );

create policy "Admins can insert series."
  on series for insert
  with check ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

create policy "Admins can update series."
  on series for update
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

create policy "Admins can delete series."
  on series for delete
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );


-- COSPLAY SETS
create table cosplay_sets (
  id bigint generated by default as identity primary key,
  character text not null,
  series_id bigint references series(id),
  date date,
  cover_image text,
  description text,
  featured boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table cosplay_sets enable row level security;

create policy "Sets are viewable by everyone."
  on cosplay_sets for select using ( true );

create policy "Admins can insert sets."
  on cosplay_sets for insert
  with check ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

create policy "Admins can update sets."
  on cosplay_sets for update
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

create policy "Admins can delete sets."
  on cosplay_sets for delete
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );


-- PHOTOS
create table photos (
  id bigint generated by default as identity primary key,
  set_id bigint references cosplay_sets(id) on delete cascade not null,
  url text not null,
  caption text,
  save_count integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table photos enable row level security;

create policy "Photos are viewable by everyone."
  on photos for select using ( true );

create policy "Admins can manage photos."
  on photos for all
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );


-- PHOTO LIKES
create table photo_likes (
  user_id uuid references profiles(id) not null,
  photo_id bigint references photos(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (user_id, photo_id)
);

alter table photo_likes enable row level security;

create policy "Likes are viewable by everyone."
  on photo_likes for select using ( true );

create policy "Users can like photos."
  on photo_likes for insert
  with check ( auth.uid() = user_id );

create policy "Users can unlike photos."
  on photo_likes for delete
  using ( auth.uid() = user_id );


-- SAVED PHOTOS (Bookmarks)
create table saved_photos (
  user_id uuid references profiles(id) not null,
  photo_id bigint references photos(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (user_id, photo_id)
);

alter table saved_photos enable row level security;

create policy "Users can view their saved photos."
  on saved_photos for select
  using ( auth.uid() = user_id );

create policy "Users can save photos."
  on saved_photos for insert
  with check ( auth.uid() = user_id );

create policy "Users can unsave photos."
  on saved_photos for delete
  using ( auth.uid() = user_id );


-- COMMENTS
create table comments (
  id bigint generated by default as identity primary key,
  photo_id bigint references photos(id) on delete cascade not null,
  user_id uuid references profiles(id) not null,
  text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table comments enable row level security;

create policy "Comments are viewable by everyone."
  on comments for select using ( true );

create policy "Authenticated users can comment."
  on comments for insert
  with check ( auth.role() = 'authenticated' AND auth.uid() = user_id );

create policy "Users can delete their own comments."
  on comments for delete
  using ( auth.uid() = user_id OR exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );


-- CHAT MESSAGES
create table chat_messages (
  id bigint generated by default as identity primary key,
  user_id uuid references profiles(id) not null,
  text text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table chat_messages enable row level security;

create policy "Chat is viewable by everyone."
  on chat_messages for select using ( true );

create policy "Authenticated users can chat."
  on chat_messages for insert
  with check ( auth.role() = 'authenticated' AND auth.uid() = user_id );


-- SOCIAL LINKS
create table social_links (
  id bigint generated by default as identity primary key,
  instagram text,
  tiktok text,
  email text,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table social_links enable row level security;

create policy "Social links viewable by everyone"
  on social_links for select using (true);

create policy "Admins can update social links"
  on social_links for update
  using ( exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );

-- Insert initial social links row
insert into social_links (instagram, tiktok, email) values ('', '', '');

-- STORAGE BUCKETS (Optional, if using Supabase Storage)
-- insert into storage.buckets (id, name) values ('photos', 'photos');
-- create policy "Public Access" on storage.objects for select using ( bucket_id = 'photos' );
-- create policy "Admin Upload" on storage.objects for insert with check ( bucket_id = 'photos' and exists ( select 1 from profiles where id = auth.uid() and is_admin = true ) );
